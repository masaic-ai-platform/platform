# Default values for infra.
# This is a YAML-formatted file.
# Declare variables to be passed into your templates.

# This will set the replicaset count more information can be found here: https://kubernetes.io/docs/concepts/workloads/controllers/replicaset/
replicaCount: 1

# This sets the container image more information can be found here: https://kubernetes.io/docs/concepts/containers/images/
image:
  repository: nginx
  # This sets the pull policy for images.
  pullPolicy: IfNotPresent
  # Overrides the image tag whose default is the chart appVersion.
  tag: ""

# This is for the secrets for pulling an image from a private repository more information can be found here: https://kubernetes.io/docs/tasks/configure-pod-container/pull-image-private-registry/
imagePullSecrets: []
# This is to override the chart name.
nameOverride: ""
fullnameOverride: ""

# This section builds out the service account more information can be found here: https://kubernetes.io/docs/concepts/security/service-accounts/
serviceAccount:
  # Specifies whether a service account should be created
  create: true
  # Automatically mount a ServiceAccount's API credentials?
  automount: true
  # Annotations to add to the service account
  annotations: {}
  # The name of the service account to use.
  # If not set and create is true, a name is generated using the fullname template
  name: ""

# This is for setting Kubernetes Annotations to a Pod.
# For more information checkout: https://kubernetes.io/docs/concepts/overview/working-with-objects/annotations/
podAnnotations: {}
# This is for setting Kubernetes Labels to a Pod.
# For more information checkout: https://kubernetes.io/docs/concepts/overview/working-with-objects/labels/
podLabels: {}

podSecurityContext: {}
  # fsGroup: 2000

securityContext: {}
  # capabilities:
  #   drop:
  #   - ALL
  # readOnlyRootFilesystem: true
  # runAsNonRoot: true
  # runAsUser: 1000

# This is for setting up a service more information can be found here: https://kubernetes.io/docs/concepts/services-networking/service/
service:
  # This sets the service type more information can be found here: https://kubernetes.io/docs/concepts/services-networking/service/#publishing-services-service-types
  type: ClusterIP
  # This sets the ports more information can be found here: https://kubernetes.io/docs/concepts/services-networking/service/#field-spec-ports
  port: 80

# This block is for setting up the ingress for more information can be found here: https://kubernetes.io/docs/concepts/services-networking/ingress/
ingress:
  enabled: false
  className: ""
  annotations: {}
    # kubernetes.io/ingress.class: nginx
    # kubernetes.io/tls-acme: "true"
  hosts:
    - host: chart-example.local
      paths:
        - path: /
          pathType: ImplementationSpecific
  tls: []
  #  - secretName: chart-example-tls
  #    hosts:
  #      - chart-example.local

resources: {}
  # We usually recommend not to specify default resources and to leave this as a conscious
  # choice for the user. This also increases chances charts run on environments with little
  # resources, such as Minikube. If you do want to specify resources, uncomment the following
  # lines, adjust them as necessary, and remove the curly braces after 'resources:'.
  # limits:
  #   cpu: 100m
  #   memory: 128Mi
  # requests:
  #   cpu: 100m
  #   memory: 128Mi

# This is to setup the liveness and readiness probes more information can be found here: https://kubernetes.io/docs/tasks/configure-pod-container/configure-liveness-readiness-startup-probes/
livenessProbe:
  httpGet:
    path: /
    port: http
readinessProbe:
  httpGet:
    path: /
    port: http

# This section is for setting up autoscaling more information can be found here: https://kubernetes.io/docs/concepts/workloads/autoscaling/
autoscaling:
  enabled: false
  minReplicas: 1
  maxReplicas: 100
  targetCPUUtilizationPercentage: 80
  # targetMemoryUtilizationPercentage: 80

# Additional volumes on the output Deployment definition.
volumes: []
# - name: foo
#   secret:
#     secretName: mysecret
#     optional: false

# Additional volumeMounts on the output Deployment definition.
volumeMounts: []
# - name: foo
#   mountPath: "/etc/foo"
#   readOnly: true

nodeSelector: {}

tolerations: []

affinity: {}

qdrant:
  replicaCount: 1
  # Add more overrides as needed

community-operator:
  enabled: true
  ## Reference to one or more secrets to be used when pulling images
  ## ref: https://kubernetes.io/docs/tasks/configure-pod-container/pull-image-private-registry/
  imagePullSecrets: []
  # - name: "image-pull-secret"
  ## Operator
  operator:
    # Name that will be assigned to most of internal Kubernetes objects like
    # Deployment, ServiceAccount, Role etc.
    name: mongodb-kubernetes-operator

    # Name of the operator image
    operatorImageName: mongodb-kubernetes-operator

    # Name of the deployment of the operator pod
    deploymentName: mongodb-kubernetes-operator

    # Version of mongodb-kubernetes-operator
    version: 0.13.0

    # Uncomment this line to watch all namespaces
    # watchNamespace: "*"

    # Resources allocated to Operator Pod
    resources:
      limits:
        cpu: 1100m
        memory: 1Gi
      requests:
        cpu: 500m
        memory: 200Mi

    # PriorityClass configuration for operator
    # ref: https://kubernetes.io/docs/concepts/scheduling-eviction/pod-priority-preemption/#priorityclass
    priorityClassName: ''

    # replicas deployed for the operator pod. Running 1 is optimal and suggested.
    replicas: 1

    # Additional environment variables
    extraEnvs: []
    # environment:
    # - name: CLUSTER_DOMAIN
    #   value: my-cluster.domain

    podSecurityContext:
      runAsNonRoot: true
      runAsUser: 2000

    securityContext: {}

    # Custom labels to be added to the operator pod
    podLabels: {}

  ## Operator's database
  database:
    name: mongodb-database
    # set this to the namespace where you would like
    # to deploy the MongoDB database,
    # Note if the database namespace is not same
    # as the operator namespace,
    # make sure to set "watchNamespace" to "*"
    # to ensure that the operator has the
    # permission to reconcile resources in other namespaces
    # namespace: mongodb-database

  agent:
    name: mongodb-agent-ubi
    version: 108.0.6.8796-1
  versionUpgradeHook:
    name: mongodb-kubernetes-operator-version-upgrade-post-start-hook
    version: 1.0.10
  readinessProbe:
    name: mongodb-kubernetes-readinessprobe
    version: 1.0.23
  mongodb:
    name: mongodb-community-server
    repo: docker.io/mongodb
    imageType: ubi8

  registry:
    agent: quay.io/mongodb
    versionUpgradeHook: quay.io/mongodb
    readinessProbe: quay.io/mongodb
    operator: quay.io/mongodb
    pullPolicy: Always

  # Set to false if CRDs have been installed already. The CRDs can be installed
  # manually from the code repo: github.com/mongodb/mongodb-kubernetes-operator or
  # using the `community-operator-crds` Helm chart.
  community-operator-crds:
    enabled: false

  # Deploys MongoDB with `resource` attributes.
  createResource: true
  resource:
    name: mongodb
    version: 6.0.5
    members: 1
    tls:
      enabled: false

      # Installs Cert-Manager in this cluster.
      useX509: false
      sampleX509User: false
      useCertManager: false
      certificateKeySecretRef: tls-certificate
      caCertificateSecretRef: tls-ca-key-pair
      certManager:
        certDuration: 8760h   # 365 days
        renewCertBefore: 720h   # 30 days

    # if using the MongoDBCommunity Resource, list any users to be added to the resource
    # users:
    #   - name: mongodb-user
    #     db: admin
    #     passwordSecretRef: # a reference to the secret that will be used to generate the user's password
    #       name: mongodb-admin-password
    #     roles:
    #       - name: clusterAdmin
    #         db: admin
    #       - name: userAdminAnyDatabase
    #         db: admin
    #       - name: readWriteAnyDatabase
    #         db: admin
    #       - name: dbAdminAnyDatabase
    #         db: admin
    #     scramCredentialsSecretName: mongodb-scram

qdrant:
  enabled: true
  replicaCount: 1

  image:
    repository: docker.io/qdrant/qdrant
    pullPolicy: IfNotPresent
    tag: ""
    useUnprivilegedImage: true

  imagePullSecrets: []
  nameOverride: ""
  fullnameOverride: ""
  args: ["./config/initialize.sh"]
  # env:
  #   - name: QDRANT__SERVICE__API_KEY
  #     valueFrom:
  #       secretKeyRef:
  #         name: "qdrant"
  #         key: "apiKey"

  service:
    type: ClusterIP
    additionalLabels: {}
    annotations: {}
    loadBalancerIP: ""
    ports:
      - name: http
        port: 6333
        targetPort: 6333
        protocol: TCP
        checksEnabled: true
      - name: grpc
        port: 6334
        targetPort: 6334
        protocol: TCP
        checksEnabled: false
      - name: p2p
        port: 6335
        targetPort: 6335
        protocol: TCP
        checksEnabled: false

  ingress:
    enabled: false
    ingressClassName: ""
    additionalLabels: {}
    annotations: {}
    hosts:
      - host: example-domain.com
        paths:
          - path: /
            pathType: Prefix
            servicePort: 6333
    tls: []

  livenessProbe:
    enabled: true
    initialDelaySeconds: 5
    periodSeconds: 5
    timeoutSeconds: 1
    failureThreshold: 6
    successThreshold: 1

  readinessProbe:
    enabled: true
    initialDelaySeconds: 5
    periodSeconds: 5
    timeoutSeconds: 1
    failureThreshold: 6
    successThreshold: 1

  startupProbe:
    enabled: true
    initialDelaySeconds: 10
    periodSeconds: 5
    timeoutSeconds: 1
    failureThreshold: 100
    successThreshold: 1

  additionalLabels: {}
  podAnnotations: {}
  podLabels: {}

  resources:
    requests:
      cpu: 2
      memory: 1Gi
    limits:
      cpu: 2
      memory: 1Gi

  containerSecurityContext:
    runAsNonRoot: true
    runAsUser: 1000
    runAsGroup: 2000
    allowPrivilegeEscalation: false
    privileged: false
    readOnlyRootFilesystem: true
    capabilities:
      drop:
        - "ALL"

  podSecurityContext:
    fsGroup: 3000
    fsGroupChangePolicy: Always
    runAsNonRoot: true
    runAsUser: 1000
    runAsGroup: 2000
    seccompProfile:
      type: RuntimeDefault

  lifecycle:
    preStop:
      exec:
        command: ["sleep", "3"]

  updateVolumeFsOwnership: true

  nodeSelector: {}

  tolerations: []

  affinity: {}

  topologySpreadConstraints: []

  persistence:
    accessModes: ["ReadWriteOnce"]
    size: 5Gi
    annotations: {}

  snapshotPersistence:
    enabled: false
    accessModes: ["ReadWriteOnce"]
    size: 10Gi
    annotations: {}

  snapshotRestoration:
    enabled: false
    pvcName: snapshots-pvc
    mountPath: /qdrant/snapshot-restoration
    snapshots:

  config:
    telemetry_disabled: true
    log_level: WARN
    cluster:
      enabled: true
      p2p:
        port: 6335
        enable_tls: false
      consensus:
        tick_period_ms: 100

  sidecarContainers: []

  metrics:
    serviceMonitor:
      enabled: false
      additionalLabels: {}
      scrapeInterval: 30s
      scrapeTimeout: 10s
      targetPort: http
      targetPath: "/metrics"
      metricRelabelings: []
      relabelings: []

  serviceAccount:
    annotations: {}

  priorityClassName: ""

  shareProcessNamespace: false

  podManagementPolicy: Parallel

  podDisruptionBudget:
    enabled: false
    maxUnavailable: 1
    unhealthyPodEvictionPolicy: ""

  additionalVolumes: []

  additionalVolumeMounts: []

  chartTests:
    dbInteraction:
      image: registry.suse.com/bci/bci-base:latest

signoz:
  enabled: true
  # Global override values
  global:
    # -- Overrides the Image registry globally
    imageRegistry: null
    # -- Global Image Pull Secrets
    imagePullSecrets: []
    # -- Overrides the storage class for all PVC with persistence enabled.
    # If not set, the default storage class is used.
    # If set to "-", storageClassName: "", which disables dynamic provisioning
    storageClass: null
    # -- Kubernetes cluster domain
    # It is used only when components are installed in different namespace
    clusterDomain: cluster.local
    # -- Kubernetes cluster name
    # It is used to attached to telemetry data via resource detection processor
    clusterName: ""
    # -- Kubernetes cluster cloud provider along with distribution if any.
    # example: `aws`, `azure`, `gcp`, `gcp/autogke`, `hcloud`, `other`
    # Based on the cloud, storage class for the persistent volume is selected.
    # When set to 'aws' or 'gcp' along with `installCustomStorageClass` enabled, then new expandible storage class is created.
    cloud: other

mongodb:
  secrets:
    create: true
    adminPassword: "mongodbAdminPassword123"
